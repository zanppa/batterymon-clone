#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vi:ts=4 sw=4 et

import dbus
import pygtk
import gtk
import glib
from optparse import OptionParser
from collections import namedtuple
import os
import sys

import gettext

_ = lambda msg: gettext.dgettext('batterymon', msg)

# {{{ code modules
#from preferences import prefs
#from settings import config
try:
    # Try importing from the system-wide directory
    from batterymon.logger import logger_init
except ImportError:
    # Try importing from the same directory
    from logger import logger_init
#}}}


# {{{ Desktop notifications init
try:
    import pynotify
    if not pynotify.init("Battery Monitor"):
        print(_("There was an error initializing the notification system. Notifications won't work."))
except:
    print(_("You do not seem to have python-notify installed. Notifications won't work."))
    pynotify = None
#}}}


# {{{ Program defaults
VERSION="1.3.0"
logger = logger_init()
#}}}


# {{{ Utility to parse /proc/acpi/*/*/* files
def parse_proc_acpi_file(f):
    '''"f" must be a File-like object.

    Returns the parsed data as a dict.
    '''

    d = {}
    for line in f:
        if ':' in line:
            key, value = line.split(':', 1)
            key = key.strip()
            value = value.strip()
            d[key] = value

    return d
#}}}


# {{{ AcAdapterDetector
class AcAdapterDetector:
    def __init__(self):
        pass

    def get_all(self):
        basepath = '/proc/acpi/ac_adapter'
        ac_adapters = []

        for name in os.listdir(basepath):
            # dirname is '/proc/acpi/ac_adapter/AC0'
            dirname = os.path.join(basepath, name)
            ac_adapters.append(AcAdapter(dirname))

        logger.debug("Found %d AC adapter(s)" % len(ac_adapters))

        return ac_adapters
#}}}


# {{{ AcAdapter
class AcAdapter:
    def __init__(self, dirname):
        self.property_modified_handler = None

        self.__dirname = dirname
        self.__state_filename = os.path.join(dirname, 'state')

        # True = on line; False = off-line
        self.__old_state = True

        if not os.path.isfile(self.__state_filename):
            raise Exception("No AC adapter found")

    def update(self):
        with open(self.__state_filename) as f:
            data = parse_proc_acpi_file(f)

        state = data.get('state', None)
        if state == 'on-line':
            present = True
        elif state == 'off-line':
            present = False
        else:
            # Unknown or missing value
            return

        logger.debug("Adapter is present: %s" % present)

        if self.__old_state != present:
            if self.property_modified_handler:
                self.property_modified_handler(present)
            else:
                logger.warn("No AC adapter property modified handler, ignoring status update")

        self.__old_state = present
#}}}


# {{{ BatteryDetector
class BatteryDetector:
    def __init__(self):
        pass

    def get_all(self):
        basepath = '/proc/acpi/battery'
        batteries = []

        for name in os.listdir(basepath):
            # dirname is '/proc/acpi/battery/BAT0'
            dirname = os.path.join(basepath, name)
            batteries.append(Battery(dirname))

        logger.debug("Found %d battery(ies)" % len(batteries))

        return batteries
#}}}


# {{{ Battery
class Battery:
    def __init__(self, dirname):
        self.property_modified_handler = None

        self.__dirname = dirname
        self.__state_filename = os.path.join(dirname, 'state')
        self.__info_filename = os.path.join(dirname, 'info')

        self.remaining_time = "unknown"  ## added this or the program crashes on a full battery

    def update(self):
        with open(self.__state_filename) as f:
            data = parse_proc_acpi_file(f)
        with open(self.__info_filename) as f:
            data.update(parse_proc_acpi_file(f))

        present = (data.get('present', None) == 'yes')
        logger.debug("battery.present: %s" % str(present))

        charging_state = data.get('charging state', None)
        if charging_state == 'charged':
            is_charging = False
            is_discharging = False
        elif charging_state == 'charging':
            is_charging = True
            is_discharging = False
        elif charging_state == 'discharging':
            is_charging = False
            is_discharging = True

        logger.debug("battery.is_charging: %s" % str(is_charging))
        logger.debug("battery.is_discharging: %s" % str(is_discharging))

        design_capacity = data.get('design capacity', None)
        remaining_capacity = data.get('remaining capacity', None)
        present_rate = data.get('present rate', None)

        if design_capacity:
            # '51260 mWh' -> 51260
            design_capacity = int(design_capacity.split()[0])
        if remaining_capacity:
            # '28435 mWh' -> 28435
            remaining_capacity = int(remaining_capacity.split()[0])
        if present_rate:
            # '23111 mW' -> 23111
            present_rate = int(present_rate.split()[0])

        if design_capacity and remaining_capacity:
            charge_level = 100 * remaining_capacity / design_capacity
        else:
            charge_level = 0
        logger.debug("battery.percentage: %s" % str(charge_level))

        # Converting mWh to mWs, and then dividing by mW, result is seconds
        if present_rate:
            remaining_time = (remaining_capacity * 60 * 60) // present_rate
        else:
            remaining_time = -1
        logger.debug("battery.remaining_time: %s" % str(remaining_time))

        remaining_time = self.__str_time(remaining_time)

        if self.property_modified_handler:
            self.property_modified_handler(BatteryInfo(charge_level, remaining_time, is_charging, is_discharging, present))
        else:
            logger.warn("No property modified handler, ignoring battery status update")

    def __str_time(self, seconds):
        if seconds <= 0:
            return 'Unknown'

        minutes = seconds // 60

        hours = minutes // 60
        minutes = minutes % 60

        logger.debug("Minutes: %s" % str(minutes))
        logger.debug("Hours: %s" % str(hours))

        #FIXME: The string below needs to be i18n-ized properly
        return self.__format_time(hours, "Hour", "Hours") + " " + self.__format_time(minutes, "Minute", "Minutes")

    def __format_time(self, time, singular, plural):
        if time == 0:
            return ""
        elif time == 1:
            return "1 %s" % singular
        else:
            return "%s %s" % (time, plural)
#}}}

BatteryInfo = namedtuple('BatteryInfo', 'charge_level remaining_time is_charging is_discharging present')


#{{{ Theme
class Theme:
    local_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'icons')
    system_path = '/usr/share/batterymon/icons'

    def __init__(self, theme):
        self.theme = theme
        self.iconpath = self.__resolve_iconpath()

        if not self.validate(theme):
            logger.error("Theme %s does not exists, falling back to default" % theme)
            self.theme = "default"

            if not self.validate("default"):
                logger.critical("Default theme does not exists, fatal")
                exit()

        logger.debug("Theme %s validated" % self.theme)

    def __resolve_iconpath(self):
        for path in [self.local_path, self.system_path]:
            themedir = os.path.join(path, self.theme)
            if os.path.isdir(themedir):
                logger.debug('Using %s' % (themedir,))
                return themedir

    @classmethod
    def list_all_themes(cls):
        print "Themes:"
        temp = []
        for path in [cls.local_path, cls.system_path]:
            try:
                temp.extend(os.listdir(path))
            except OSError:
                pass
        temp.sort()
        print str(temp)

    def get_icon(self, name):
        return os.path.join(self.iconpath, "battery_%s.png" % (name,))

    def file_exists(self, f):
        try:
            open(f)
        except IOError:
            return False
        else:
            return True

    def validate(self, theme):
        all_icons = ["1", "2", "3", "4", "5", "empty", "full",
        "charging_1","charging_2","charging_3","charging_4","charging_5",
        "charging_full","charging_empty"]

        for icon in all_icons:
            if not self.file_exists(self.get_icon(icon)):
                logger.debug("Could not find icon %s" % self.get_icon(icon))
                return False

        return True
#}}}


# {{{ PowerEventListener
class PowerEventListener:
    def ac_property_modified(self, present):
        pass

    def battery_property_modified(self, battery_info):
        pass
#}}}


# {{{ Systray
class Systray(PowerEventListener):
    def __init__(self, theme):
        self.theme = theme
        self.tray_object= gtk.StatusIcon()
        self.tray_object.set_visible(False)
        #self.set_icon("full")
        self.tray_object.set_blinking(False)
        self.tray_object.connect("popup_menu", self.rightclick_menu)

        self.show_trayicon(1) ## fixed to one for now

    def show_trayicon(self,value):
       setting = value
       ### only changing on startup

       if setting == 3 : ## only show if charing or discharging
            self.tray_object.set_visible(False)
            return

       if setting == 1: ### always show an icon
                self.tray_object.set_visible(True)
                return

       if setting == 2: ## only show when discharging
            self.tray_object.set_visible(True)

            return

    def read_settings(self):
       settings=config()
       result = settings.read_settings_int("show_icon")

       return result

    def battery_property_modified(self, battery):
        if battery.is_charging:
            self.tray_object.set_tooltip(_("On AC (Charging) \nBattery Level: %s%%") % battery.charge_level)
            logger.debug("Charging\n Battery Percentage %s" % battery.charge_level)

        elif battery.is_discharging:
            self.tray_object.set_tooltip(_("Battery Level: %s%% \nTime remaining %s") % (battery.charge_level, battery.remaining_time))
            logger.debug("Battery Percentage %s \nTime remainging: %s" % (battery.charge_level, battery.remaining_time))

        else:
            self.tray_object.set_tooltip(_("On AC \nBattery Level: %s%%") % battery.charge_level)
            logger.debug("On AC")

        if battery.is_charging == 0 and battery.is_discharging == 0 :

            self.set_icon("charging_full")
            return


        if battery.charge_level > 96:
            if battery.is_charging ==0:
                self.set_icon("full")
            else:
                self.set_icon("charging_full")
                self.tray_object.set_blinking(False)

        elif battery.charge_level > 80:
            if battery.is_charging ==0:
                self.set_icon("5")
            else:
                self.set_icon("charging_5")

        elif battery.charge_level > 64:
            if battery.is_charging ==0:
                self.set_icon("4")
            else:
                self.set_icon("charging_4")

        elif battery.charge_level > 48:
            if battery.is_charging ==0:
                self.set_icon("3")
            else:
                self.set_icon("charging_3")

        elif battery.charge_level > 32:
            if battery.is_charging ==0:
                self.set_icon("2")
            else:
                self.set_icon("charging_2")

        elif battery.charge_level >16:
            if battery.is_charging ==0:
                self.set_icon("1")
            else:
                self.set_icon("charging_1")
        else:
            if battery.is_charging ==0:
                self.set_icon("empty")
                self.tray_object.set_blinking(True)
            else:
                self.tray_object.set_blinking(False)
                self.set_icon("charging_empty")
        return

    def rightclick_menu(self, button, widget, event):
        menu = gtk.Menu()
        about_menu = gtk.ImageMenuItem(gtk.STOCK_ABOUT)
        about_menu.connect('activate', self.about)
        exit_menu = gtk.ImageMenuItem(gtk.STOCK_CLOSE)
        exit_menu.connect('activate', self.close)
        pref_menu = gtk.ImageMenuItem(gtk.STOCK_PREFERENCES
)
        pref_menu.connect('activate',self.preferences)
        menu.append(about_menu)
        #menu.append(pref_menu)
        menu.append(exit_menu)
        menu.show_all()
        menu.popup(None, None, None, 2, event)

    def preferences(self,button):
        show_prefs = prefs()

    def close(self,button):
        sys.exit(0)

    def about(self, button):
        about_dg = gtk.AboutDialog()
        about_dg.set_name(_("Battery Monitor"))
        about_dg.set_version(VERSION)
        about_dg.set_authors(["Matthew Horsell", "Tomas Kramar", "Denilson SÃ¡"])
        about_dg.connect("response", lambda d, r: d.destroy())
        about_dg.show()

    def set_icon(self,name):
        self.tray_object.set_from_file(self.theme.get_icon(name))
        self.Icon_name = name
        logger.debug("Icon updated")
        logger.debug("Icon Name: %s" % name)
#}}}


#{{{ Notification
class NotificationHelper:
    def __init__(self, theme):
        self.theme = theme

    def notify(self, title, message, icon):
        if pynotify:
            n = pynotify.Notification(title, message)
            iconf = self.theme.get_icon(icon)
            logger.debug("DEBUG Notification icon " +iconf)
            icon = gtk.gdk.pixbuf_new_from_file_at_size(iconf, 46, 46)
            n.set_icon_from_pixbuf(icon)
            n.show()
            logger.debug("Notification shown")
#}}}


#{{{ commandline
def passargs():
    parser = OptionParser(usage='usage: %prog [options] ', version=VERSION, description="Simple Battery Monitor")
    parser.add_option("-n", "--notify-at"  , action="store", help="notify me when battery level is lower than the provided value", dest="notification_level", default="10")
    parser.add_option("-c", "--critical"   , action="store", help="set critical level", dest="critical_level", default="5")
    parser.add_option("-e", "--on-critical", action="store", help="run this command on critical power level", dest="critical_command", default=None)
    parser.add_option("-i", "--interval"   , action="store", help="polling interval (in seconds)" , dest="polling_interval", default="10")
    parser.add_option("-t", "--theme"      , action="store", help="set icon theme", dest="theme", default="default")
    parser.add_option("-l", "--list-themes", action="store_true", help="list all avalable themes", dest="list_themes", default=False)
    parser.add_option("-d", "--debug"      , action="store_true", help="run in debug mode" , dest="debug", default=False)
    (options, args) = parser.parse_args()

    return options
#}}}


# {{{ PowerManager
class PowerManager:
    def __init__(self):
        self.listeners = []
        self.adapters = AcAdapterDetector().get_all()
        self.batteries = BatteryDetector().get_all()

        for adapter in self.adapters:
            adapter.property_modified_handler = self.__ac_property_modified_handler

        for battery in self.batteries:
            battery.property_modified_handler = self.__battery_property_modified_handler

    def __ac_property_modified_handler(self, present):
        for listener in self.listeners:
            listener.ac_property_modified(present)

    def __battery_property_modified_handler(self, battery):
        for listener in self.listeners:
            listener.battery_property_modified(battery)

    def update(self):
        for adapter in self.adapters:
            adapter.update()

        for battery in self.batteries:
            battery.update()

        # Since this is being called on a GTK timer, it needs to return True
        # (if it returns False, the timer stops)
        return True
# }}}


# {{{ Notificator
class Notificator(PowerEventListener):
    def __init__(self, theme, low_level=-1, critical_level=-1):
        self.n = NotificationHelper(theme)
        self.low_level = low_level
        self.notified = False
        self.critical_level = critical_level
        self.critically_notified = False
        logger.debug("self.low_level " + str(self.low_level))

    def ac_property_modified(self, present):
        if present:
            self.n.notify(_("On AC"), _("You are currently running on AC"),"charging_full")
        else:
            self.n.notify(_("On Battery"), _("AC adapter unplugged, running on battery"),"full")

    def battery_property_modified(self, battery):
        if battery.charge_level <= self.low_level and not self.notified:
            self.n.notify(_("Low Battery"), _("You have approximately <b>%s</b> remaining") % battery.remaining_time,"empty")
            self.notified = True

        if battery.charge_level <= self.critical_level and not self.critically_notified:
            self.n.notify(_("Critical Battery"), _("You have approximately <b>%s</b> remaining") % battery.remaining_time,"empty")
            self.critically_notified = True


        if battery.is_charging and battery.charge_level > self.critical_level:
            self.critically_notified = False

        if battery.is_charging and battery.charge_level > self.low_level:
            self.notify = False
#}}}


#{{{ CommandRunner
class CommandRunner(PowerEventListener):
    def __init__(self, power_level, command):
        self.power_level = power_level
        self.command = command

    def battery_property_modified(self, battery):
        if int(battery.charge_level) <= int(self.power_level) and self.command:
            logger.debug("Running command '%s'" % self.command)
            os.system(self.command)
#}}}


def main():
    cmdline = passargs()

    if cmdline.list_themes:
        Theme.list_all_themes()
        sys.exit(1)
    if cmdline.debug:
        logger.set_level("debug")

    theme = Theme(cmdline.theme)

    systray = Systray(theme)
    notificator = Notificator(theme, int(cmdline.notification_level), int(cmdline.critical_level))
    executor = CommandRunner(int(cmdline.critical_level), cmdline.critical_command)

    pm = PowerManager()
    pm.listeners.append(notificator)
    pm.listeners.append(systray)
    pm.listeners.append(executor)

    pm.update()
    glib.timeout_add_seconds(int(cmdline.polling_interval), pm.update)

    gtk.main()

if __name__ == "__main__":
    main()
